"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = require("react");
const utils_1 = require("aws-amplify/utils");
const utils_2 = require("./utils");
const logger = new utils_1.ConsoleLogger('Authenticator');
function useFieldValues({ componentName, fields = [], handleBlur, handleChange, handleSubmit, validationErrors, }) {
    const [touched, setTouched] = (0, react_1.useState)({});
    const [fieldValidationErrors, setFieldValidationErrors] = (0, react_1.useState)({});
    const isVerifyUserRoute = componentName === 'VerifyUser';
    const isSelectMfaTypeRoute = componentName === 'SelectMfaType';
    const isRadioFieldComponent = isVerifyUserRoute || isSelectMfaTypeRoute;
    // initialize values based on route
    // select mfa type screen should auto select first radio option
    const [values, setValues] = (0, react_1.useState)(() => {
        const result = {};
        if (isSelectMfaTypeRoute) {
            const initialValue = fields[0]?.value;
            if (initialValue) {
                result.mfa_type = initialValue;
            }
        }
        if (isVerifyUserRoute) {
            const initialValue = fields[0]?.name;
            if (initialValue) {
                result.unverifiedAttr = initialValue;
            }
        }
        return result;
    });
    const sanitizedFields = (0, react_1.useMemo)(() => {
        if (!Array.isArray(fields)) {
            logger.warn(`Invalid fields type of ${typeof fields} passed to ${componentName}. fields must be of type array.`);
            return [];
        }
        if (isVerifyUserRoute) {
            return (0, utils_2.getSanitizedVerifyUserFields)(fields);
        }
        if (isSelectMfaTypeRoute) {
            return (0, utils_2.getSanitizedSelectMfaTypeFields)(fields);
        }
        return (0, utils_2.getSanitizedTextFields)(fields, componentName);
    }, [componentName, fields, isVerifyUserRoute, isSelectMfaTypeRoute]);
    const fieldsWithHandlers = sanitizedFields.map((field) => {
        if ((0, utils_2.isRadioFieldOptions)(field)) {
            const onChange = (value) => {
                // call `onChange` passed as radio `field` option
                field.onChange?.(value);
                // on VerifyUser route, set `name` as value of 'unverifiedAttr'
                // on SelectMfaTYpe route, set `name` as value of 'mfa_type'
                const fieldName = isVerifyUserRoute
                    ? 'unverifiedAttr'
                    : isSelectMfaTypeRoute
                        ? 'mfa_type'
                        : field.name;
                setValues((prev) => ({ ...prev, [fieldName]: value }));
            };
            const result = {
                ...field,
                onChange,
            };
            // bind selected boolean attribute for radio field
            if (isSelectMfaTypeRoute) {
                result.selected = values.mfa_type === field.value;
            }
            if (isVerifyUserRoute) {
                result.selected = values.unverifiedAttr === field.name;
            }
            return result;
        }
        const { name, label, labelHidden, ...rest } = field;
        const onBlur = (event) => {
            setTouched({ ...touched, [name]: true });
            // call `onBlur` passed as text `field` option
            field.onBlur?.(event);
            // call machine blur handler
            handleBlur({ name, value: values[name] });
            setFieldValidationErrors({
                ...fieldValidationErrors,
                [name]: (0, utils_2.runFieldValidation)(field, values[name], validationErrors),
            });
        };
        const onChangeText = (value) => {
            // call `onChangeText` passed as text `field` option
            field.onChangeText?.(value);
            // call machine change handler
            handleChange({ name, value });
            if (touched[name]) {
                setFieldValidationErrors({
                    ...fieldValidationErrors,
                    [name]: (0, utils_2.runFieldValidation)(field, value, validationErrors),
                });
            }
            setValues({ ...values, [name]: value });
        };
        return {
            ...rest,
            label: labelHidden ? undefined : label,
            onBlur,
            onChangeText,
            name,
            value: values[name],
        };
    });
    const disableFormSubmit = isVerifyUserRoute
        ? !values.unverifiedAttr
        : isSelectMfaTypeRoute
            ? !values.mfa_type
            : fieldsWithHandlers.some(({ required, value }) => required && !value);
    const handleFormSubmit = () => {
        const submitValue = isRadioFieldComponent
            ? values
            : fieldsWithHandlers.reduce((acc, { name, value = '', type }) => {
                /*
                      For phone numbers pass the first 3 charactes from value as dialCode until we support a dialCode picker
                  */
                return type === 'phone'
                    ? {
                        ...acc,
                        country_code: value?.substring(0, 3),
                        [name]: value?.substring(3, value.length),
                    }
                    : { ...acc, [name]: value };
            }, {});
        handleSubmit?.(submitValue);
    };
    return {
        fields: fieldsWithHandlers,
        disableFormSubmit,
        fieldValidationErrors: { ...fieldValidationErrors, ...validationErrors },
        handleFormSubmit,
    };
}
exports.default = useFieldValues;
